%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%	String Transformations - ICP Special Case                                  %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ICP Special Case}\label{sec:icpSpecialCase}

It turns out that if the candidate language is specified using a DFA and both $\spat$ and $\tpat$ are copyless, there is a better upper bound
for the invariance-checking problem.

\begin{theorem}
	Let $\A$ be a DFA and let $\alpha := (\spat, \guardL, \T, \tpat)$ be an action such that $\spat, \tpat$ are copyless patterns. In this case, the problem of deciding whether $\post(L(\A), \alpha) \subseteq L(\A)$ is in \conp.
\end{theorem}

\begin{proof}
	We will show that deciding whether $\post(L(\A), \alpha) \cap \overline{L(\A)} \neq \emptyset$ is in \np, by proving a short witness 
	property. Suppose $\ssub$ is a valuation such that $\ssub(\spat)\cdot (\alpha,\ssub) \not\in L(A)$. Then we will prove that there exists
	a valuation $\ssub'$ such that $\ssub'(\spat)\cdot (\alpha,\ssub') \not\in L(A)$ and $|\ssub'(x)|$ is bounded by a polynomial in the
	size of the input for all variables $x$. This suffices, since the presence of such a $\ssub'$ can be guessed and verified in
	polynomial time.

	For a valuation $\ssub$ such that $\ssub(\spat)\cdot (\alpha,\ssub) \not\in L(A)$ and for a variable $x$, suppose $\ssub(x)=w$.
	We will show how to drop portions of $w$ to get a shorter string $w'$ that still has all the following desirable properties of $w$. Let
	$M_x$ be the Mealy machine for $\T(x)$.
	\begin{enumerate}
		\item The run of $A$ on $\ssub(\spat)$ enters $w$ at state $p$ and leaves at state $p'$.
		\item The run of $A_x$ (an automaton for $\guardL(x)$) on $w$ starts at state $q$ and ends at state $q'$.
		\item The run of $M_x$ on $w$ starts at state $r$ and ends at state $r'$.
		\item The run of $A$ on $\ssub_\alpha(\tpat)$ enters $\T(x)(w)$ at state $s$ and leaves at $s'$.
	\end{enumerate}
	Let the first three runs above be in states $p_i, q_i, r_i$ respectively just before reading $w[i]$, the $i$\textsuperscript{th}
	letter of $w$. Let the fourth run be in state $s_i$ just before reading $w_i^t$, the string output by $M_x$ at position $i$
	while reading $w$. For some $i, j$ with $i \ne j$,  if the tuple $\langle p_i, q_i, r_i, s_i\rangle$ is equal to the tuple
	$\langle p_j, q_j, r_j, s_j\rangle$, then we can drop the portion of $w$ between $i$ and $j$ and the shorter string will still have
	all the four properties of $w$. We can continue this till we get a string of length at most $|\A_x||\A|^2|M_x|$. For every variable
	$x$, the desired valuation $\ssub'$ maps $x$ to a short string as described above, thus proving the small model property.\qed
\end{proof}

The above technique fails if $\A$ is an NFA. In that case, it is not enough to ensure that fourth run in the above proof is a rejecting
run --- we will have to prove that \emph{all} runs of $A$ on $\ssub_\alpha(\tpat)$ are rejecting. The above technique fails if $\spat$
is copyful. If a variable $x$ occurs more than once, then the first run in the proof above will pass through $w$ more than once and we
will have to take care of all those passes. Hence, in place of checking that the four tuple $\langle p_i, q_i, r_i, s_i\rangle$ repeats,
we will have to consider tuples whose dimension depends on the input and we will not get a small model property. Similarly, the above
technique breaks down if $\tpat$ is copyful.

Next we prove a matching lower bound for this case.
\begin{lemma}
	Let $\alpha$ be an action with copyless source and target patterns. Then the problem of checking whether a given DFA describes an
	invariant for $\alpha$ is \conph.
\end{lemma}
\begin{proof}
	We will give a reduction from the complement of the problem of finding a clique in a graph. Given a number $k$ and a graph over $n$
	vertices, the problem is to check if the graph contains a $k$-clique as a subgraph. We know that this problem is \npc\ \cite{K1972}.

Suppose we are given a graph $G$  with vertex set $V := \set{v_1, v_2, \dots, v_n}$ and  a number $k \leq 
n$. We will design an action $\action$ and the candidate invariant language $L$  with the following goal: The action $\action$  is enabled on an input string from $L$ only if it is of the form $ I a_{i_1} \underbrace{v_{i_1}v_{i_1}\dots 
v_{i_1}}_{k} a_{i_2} \underbrace{v_{i_2}v_{i_2}\dots 
v_{i_2}}_{k}\dots a_{i_k} \underbrace{v_{i_k}v_{i_k}\dots v_{i_k}}_{k}$  
with $1 \le i_1 < i_2 < \dots i_k \le n$.  That is, it guesses $k$ 
vertices, repeating each of them $k$ times in the string. This action 
will produce the output string $$\theta ~ a_{i_1} ~ v_{i_1} v_{i_2} 
v_{i_3} \dots v_{i_k} ~ a_{i_2} ~ v_{i_1}v_{i_2} v_{i_3} \dots  v_{i_k} ~ 
a_{i_3}~ \dots ~ a_{i_k} ~ v_{i_1}v_{i_2} \dots v_{i_k}. $$ Note that this 
output string has all the $k$ guessed vertices in every block 
(delimited by $a_i$). The output string will belong to $L$ only if at 
least two of these vertices do not have an edge between them, i.e., 
these $k$ vertices do not form a clique. The output string will not 
belong to $L$ (that is, $L$ is not an invariant) if the $k$ guessed 
vertices form a clique. 

We require the source and target patterns of the action to be copyless. For this we will use $k^2$ variables of the form $x_i^j$ to represent the vertices in the string. Further there are variables $S_i$ to represent the delimiters. Let us describe the action $\action$ formally.


Let $\Sigma = V \cup \set{a_1,a_2,\ldots, a_n, \theta, 
	I}$ and $\var=\set{S_1, \ldots, S_k} \cup \{x_i^j \mid  1 \le i \le k, 1 \le j 
\le k\}$. 
The  action $\action$ is given by
\begin{itemize}
	\item \textbf{Source pattern:} $I~S_1~x_1^1~x_1^2\dots x_1^{k}~ S_2~x_2^1~x_2^2\dots x_2^{k} ~S_3 \dots S_k~x_k^1~x_k^2\dots x_k^{k}$.
	\item \textbf{Guard languages:} $x_i^j \mapsto \set{v_1, v_2, \dots, v_n}, S_i \mapsto \set{a_1, a_2, \dots, a_n}$
	\item \textbf{Transduction} $\T$ maps every variable to the identity transduction.
	\item \textbf{Target Pattern:} $\theta ~ S_1 ~x_1^1 ~x_2^1 \dots  x_k^1~ 
	S_2 ~x_1^2 ~ x_2^2  \dots  x_k^2 ~S_3
	\dots
	S_k~x_1^{k}~x_2^{k}\dots x_k^k$.
\end{itemize}

\begin{figure}[t]
	\centering
	\begin{tikzpicture}
		\tikzset{every state/.style={fill=blue!10,minimum size=15pt,inner sep = 1pt}}
		\tikzset{every state/.style={draw, fill=blue!10,minimum size=15pt,inner sep = 1pt}}
		\tikzset{gadget/.style={draw, thick,rectangle,  fill=red!10,minimum size=20pt,inner sep = 1pt}}
		% Input Vertices
		\node[initial, state] (n0) at (1.5,-6.2) {0};
		\node[state, accepting] (n1) at (1.5,-4.4) {in};
		\node[state, accepting] (ig1) at (3,-4.4) {$i_1$};
		\node[state, accepting] (ig2) at (4.5,-4.4) {$i_2$};
		\node[state, accepting] (ig3) at (6,-4.4) {$i_3$};
		\node (e) at (7.5,-4.4) {\ldots};
		\node[state, accepting] (ign) at (9,-4.4) {$i_n$};
		\node [state] (inSink) at (10.5, -5.6) {$X_i$};
		% Input Edges
		\path [-stealth, thick]
		(n0) edge node {$I$} (n1)
		(n1) edge node[below] {$a_1$} (ig1)
		(ig1) edge node[below] {$a_2$} (ig2)
		(ig2) edge node[below] {$a_3$} (ig3)
		(ig3) edge node[below] {$a_4$} (e)
		(e) edge node[below] {$a_n$} (ign)
		(n1) edge[bend left=30, inner sep = 1pt  ] node[above] {$a_2$} (ig2)
		(n1) edge[bend left = 40,] node[above, ] {$a_3$} (ig3)
		(n1) edge[bend left =50,inner sep = 1pt] node[pos = 0.75] {$a_n$} (ign)
		(ig1) edge[bend left = 30, inner sep = 1pt] node {$a_3$} (ig3)
		(ig1) edge[bend left = 40,  near end, inner sep = 1pt] node[pos = 0.7] {$a_n$} (ign)
		(ig2) edge[bend left = 30,   inner sep = 1pt] node[pos = 0.6] {$a_n$} (ign)
		(ig3) edge[bend left = 20, inner sep = 1pt] node[pos = 0.45] {$a_n$} (ign)
		(ig1) edge[loop below] node {$v_1$} (ig1)
		(ig2) edge[loop below] node {$v_2$} (ig2)
		(ig3) edge[loop below] node {$v_3$} (ig3)
		(ign) edge[loop below] node {$v_n$} (ign)	
		(n0) edge[color=gray, dotted] node {} (inSink)
		(n1) edge[color=gray, dotted, out = -40, in = 175] node {} (inSink)	
		(ig1) edge[color=gray, dotted, out = -35, in = 170] node {} (inSink)
		(ig2) edge[color=gray, dotted, out = -30, in = 160] node {} (inSink)
		(ig3) edge[color=gray, dotted, out = -20, in = 150] node {} (inSink)
		(ign) edge[color=gray, dotted] node {} (inSink);
		
		\tikzset{every state/.style={draw, fill=blue!10,minimum size=15pt,inner sep = 1pt}}
		\tikzset{gadget/.style={draw, thick,rectangle,  fill=red!10,minimum size=20pt,inner sep = 1pt}}
		% Vertices
		\node[state] (n1) at (1.5,-8) {out};
		\node[state] (og1) at (3,-8) {$o_1$};
		\node[state] (og2) at (4.5,-8) {$o_2$};
		\node[state] (og3) at (6,-8) {$o_3$};
		\node (e) at (7.5,-8) {\ldots};
		\node[state] (ogn) at (9,-8) {$o_n$};
		\node [state, accepting] (outSink) at (10.5, -6.8) {$X_o$};
		% Edges
		\path [-stealth, thick]
		(n0) edge[left] node {$\theta$} (n1)
		(n1) edge node {$a_1$} (og1)
		(og1) edge node {$a_2$} (og2)
		(og2) edge node {$a_3$} (og3)
		(og3) edge node {$a_4$} (e)
		(e) edge node {$a_n$} (ogn)
		(n1) edge[bend right = 30, below, inner sep = 1pt] node {$a_2$} (og2)
		(n1) edge[bend right = 40, below] node {$a_3$} (og3)
		(n1) edge[bend right = 50, below] node[pos = 0.78] {$a_n$} (ogn)
		(og1) edge[bend right = 30, inner sep = 1pt] node[below] {$a_3$} (og3)
		(og1) edge[bend right = 40, below, inner sep = 3pt] node[pos = 0.75] {$a_n$} (ogn)
		(og2) edge[bend right = 30, below, inner sep = 2pt] node[pos = 0.68] {$a_n$} (ogn)
		(og3) edge[bend right = 20, below, inner sep = 1pt] node {$a_n$} (ogn)				
		(og1) edge[loop above] node[above]{$\textsf{N}_1$} (og1)
		(og2) edge[loop above] node[above]{$\textsf{N}_2$} (og2)
		(og3) edge[loop above] node[above]{$\textsf{N}_3$} (og3)		
		(ogn) edge[loop above] node[above]{$\textsf{N}_n$} (ogn)
		(n1) edge[color=gray, dotted, out = 60, in =180 ] node {} (outSink)
		(og1) edge[color=gray, dotted, out = 50, in = 185] node {} (outSink)
		(og2) edge[color=gray, dotted, out = 40, in = 190] node {} (outSink)
		(og3) edge[color=gray, dotted, out = 30, in = 195] node {} (outSink)
		(outSink) edge[loop right, color=gray, dotted] node {} (outSink)
		(inSink) edge[loop right, color=gray, dotted] node {} (inSink)
		(ogn) edge[color=gray, dotted] node {} (outSink);
	\end{tikzpicture}
	\caption{The automaton $\aut$ used in the polynomial reduction from the problem of finding a clique in a graph. Here  $\textsf{N}_i$ denotes the set of  nodes at a distance at most one  from $v_i$. That is, it includes $v_i$ and all the neighbours of $v_i$. The transitions on unspecified letters go to the respective sink states, as depicted by the dotted edges.}\label{fig:conp}
\end{figure}

Now let us define the DFA  for  the potential invariant $L$. The automaton $A$ is depicted in Figure~\ref{fig:conp}. It has a top part and a bottom part. Any string that starts with the letter $I$, and hence could potentially match the input pattern, runs in the top part. Any string that starts with $\theta$, and hence all the output strings, runs in the bottom part. 
All the states in the top part are accepting, except for the sink state $X_i$. All the states in the bottom part are rejecting, except for the sink state $X_o$. 

The top part of the DFA makes sure that in a block following $a_i$, it is the same vertex $v_i$ that gets repeated. The length of each block and the number of blocks are taken care of by the source pattern. 
Thus the source pattern together with this automaton $A$ ensures that the input string is of the required form. Notice that this part does not look at the edges in the graph, and in particular does not verify that these vertices form a clique. 

The bottom part of the automaton reads strings that start with a $\theta$ and in particular the potential output strings of action $\action$. This part of the automaton makes sure that in the block following $a_i$, all the vertices appearing in the block are neighbours of $v_i$ or $v_i$ itself. The set of permitted vertices is denoted $\textsf{N}_i$, the set of all vertices at a distance at most 1 from $v_i$. Note that if the block after $a_i$ contains a vertex $v_j$ which is not in $N_i$ then it goes into the accepting sink state $X_o$.  Thus if the guessed vertices do not form a clique, the output string will be accepted by $A$. On the other hand, if the guessed vertices form a clique, then in every block the vertices encountered belong to the respective $N_i$ and the run remains in the bottom part where all states are rejecting. 

Notice that the automaton $A$ depends only on the input graph $G$, and not on the number $k$. 

If the input graph $G$ has a clique of size $k$, then there is an input string that matches the input pattern, and that produces the output string which is rejected by the automaton $A$. Thus $L(A)$ is not an invariant in this case. If the input graph does not have a clique of size $k$, then for every input string that enables the action $\action$, the output string will have a block starting at some $a_i$ containing a vertex that does not belong to the neighbour set $N_i$, and the run of $A$ on the output string will end up in the accepting sink state. Thus $L(A)$ will be an invariant in this case. \qed
\end{proof}

The $k$-clique problem is unlikely to be fixed-parameter tractable with the clique-size $k$ as the parameter, as it is \woneh\ \cite{DF1995}. Thus we get:

\begin{corollary}
Let $\alpha$ be an action with copyless source and target patterns. Then the problem of checking whether a given DFA describes an invariant for $\alpha$ is \woneh\ with the length of the patterns being the parameter.
\end{corollary}
