%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%   Tree Transformations - Introduction                                        %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:introduction-trees}

Tree transformations in various forms of machines and logics have been studied for applications such as XML processing, programming languages and HTML sanitization \cite{DVLM2015,Hosoya_2010,AK1998,MSV2000}. Classical formalisms for specifying tree transductions such as finite-state top-down and bottom-up tree transducers, macro tree transducers, attribute grammars and MSO (Monadic Second-Order) definable graph transductions typically aim for robustness with respect to decidability of the equivalence problem and operations involving regular tree languages.

We introduce a model for tree transductions, targeting scenarios where
the domain for which the transduction is defined is not necessarily
regular, and undecidability of equivalence does not render the model
useless. Expanding on the example from the abstract, consider
expressions of the form $t \cdot e_{1} + t \cdot e_{2} + \cdots + t
\cdot e_{n}$, where $n$ is any number. An equivalent expression is $t
\cdot (e_1 + e_2 + \cdots + e_n)$. Transformations like this are
routinely used in Horner's method, an efficient way to evaluate
polynomials. We consider the corresponding expression trees and model
this transformation by matching the source tree with a source pattern
and the target tree with a target pattern. The patterns are themselves
trees, which can have place holder variables to represent sub-trees
like $t$ in the above example, which must repeat in multiple
positions. The number $n$ can be arbitrary, so we need infinitely many
pairs of patterns. For the example above, for each $n >0$ we need $(x \cdot e_1 + x\cdot e_2 + \cdots + x\cdot e_n\,, \quad 
x\cdot (e_1 + e_2 + \cdots + e_n)\,)$ as a  (source pattern,  target
pattern) pair, where $x$ is a place holder
variable intended to match any  expression $t$. We represent such infinite sets (of pairs of
patterns) using (standard) tree transductions. We allow place holder
variables in patterns to be substituted with any tree, as long as it satisfies a guard condition associated with the variable. The guard condition is given by  a
regular tree language called the guard language. It allows, for example, to restrict the
expression $t$ above to be a valid expression. In some situations we may want to restrict it further, say to not contain any products inside.   In this example, the
set of source trees to which the transformation is applicable needs to
have the same sub-tree $t$ repeat in multiple positions. Thus, the set
of source trees on which transformations are defined need not be a
regular tree language in general, which makes our model different from
classical tree transductions. 

The backbone of our model is a finite representation of the infinite set of (source pattern, target pattern) pairs. Such a finite representation can be any formalism for tree transductions; in this paper we have chosen to use bimorphisms for technical convenience. Bimorphisms are given by a regular seed language $\seedLang$ and two morphisms $\phi, \psi$. The transduction is defined as the relation $\{(\phi(t), \psi(t)) \mid t \in \seedLang\}$. Over words, bimorphisms are equivalent to rational transductions \cite{Nivat68}. Over trees, bimorphisms capture subclasses of tree transducers (cf.~\cite[Section 6.5]{tata} and \cite{Engelfriet75}).
%\todo[inline]{maybe a quick seed language and morphisms for the running example here.}
For example, consider the seed language   $a b 1(0+1)^\ast (\oplus b 1(0+1)^\ast)^\ast c$. This is a regular word language over the alphabet $\{a, b, c, \oplus, 0, 1\}$. We define the morphisms $\phi, \psi$: $\{a, b, c, \oplus, 0, 1\} \to \{0,1, +, \cdot, x, (, ) \}^\ast$  as follows: $\phi= \{a \mapsto \epsilon, b \mapsto x \cdot {}, c \mapsto \epsilon, \oplus \mapsto +, 0 \mapsto 0, 1 \mapsto 1\}$ and $\psi= \{a \mapsto x \cdot (, b \mapsto \epsilon, c \mapsto ), \oplus \mapsto +, 0 \mapsto 0, 1 \mapsto 1\}$. Note that, this bimorphism generates pairs of the form $(x \cdot e_1 + x\cdot e_2 + \cdots + x\cdot e_n\,, \quad 
x\cdot (e_1 + e_2 + \cdots + e_n)\,)$ where $e_i$ is a non-zero binary
number, from the seed word $a b e_1 \oplus b e_2 \oplus \dots \oplus b
e_n c$. We may add a guard to $x$ saying that $x$ can take values only
from $1(0+1)^\ast$, capturing completely the distributivity of
multiplication over addition for binary numbers. Note that this only
required bimorphisms over words and defines transduction over words.
If instead we allow the guard language of $x$ to be any syntactically
valid expression tree, this now defines transformations from trees to
trees, though given by a bimorphism over words. In fact, if we wish
$e_1, e_2 \dots e_n$ to be also expressions, we would require
bimorphsim over trees. This case is detailed as an example in
Section~\ref{sec:illustratingExample}.%\todo{please check!}

 Notice that bimorphisms over words which does not produce placeholder variables anywhere already captures rational relations over words. Since equivalence-checking is undecidable for rational word relations
\cite{FR1968, Griffiths1968}, it is undecidable for our model as well. However
we show that the type-checking problem is decidable, for the transduction defined by bimorphisms over trees as well as producing variables in the output of both morphisms.  We first motivate the need for type-checking in the next paragraph, and give insights to our algorithm in the paragraphs following that. 
%\todo{Please check!}

Continuing with
our example from above, we may want to check that applying the
transformation does not increase the alternation between the operators
$.$ and $+$. This can be checked by verifying that if the
transformation is applied to any tree from a language $L$ consisting
of trees with alternation depth bounded by a constant $c$, the
resulting tree is in $L$ as well. On the other hand, for reasons of
numerical stability, we may be interested in ensuring that size of
sub-trees made up of only $+$ operator is bounded. It can be checked
that this regular property is not preserved by the transformation.
Instead of arithmetic expressions, if we consider boolean expressions
made up of $\land$ and $\lor$ operators, we can reason about
expressions being in normal forms like conjunctive normal form,
disjunctive normal form etc. We consider the type-checking problem in
general where the source trees have a property represented by a
regular language $L_{1}$ and output trees are required to have a
property represented by another (possibly different) regular language
$L_{2}$.

The main idea of our decision procedure for the type-checking problem
is the following observation: if the given instance of the
type-checking problem is a negative instance, a counter example is a
single tree in the seed language $S$, satisfying multiple conditions
under multiple transformations. On the source side, applying the
morphism $\phi$ to the seed tree and then applying a substitution for
the placeholder variables should result in a tree in $L_{1}$. On the
output side, applying the morphism $\psi$ to the same seed tree and
then applying the same substitution for the placeholder variables
should result in a tree in $L_{2}$. These conditions can be
checked by an alternating tree automaton running on trees in the seed
language, thus reducing the type checking problem to emptiness
checking of alternating tree automata.

Along the way, we consider some related/simpler problems. The simple question of whether a given tree matches a given pattern is \nptc, a result known already for words \cite{tata}. The special case of the type checking problem where the transformation is given by a single pair of patterns is \exptc. This generalizes the work of pattern based string transformations \cite{AMP2022} to trees.

\paragraph*{Related work}
Pattern-based text transformations was considered for words in \cite{AMP2022}, but these consisted only of one pair of patterns. We extend this in two ways --- by having  transformations of trees, and by having a formalism that consists of potentially infinitely many  pairs of patterns. 

There are many transducer models for trees. Our transformations
subsume classical top-down and bottom-up tree transducers, even
without any variables, thanks to the bimorphism feature. In fact it
subsumes any relation on trees definable by bimorphisms \cite[Chapter
6]{tata}. However it is incomparable to streaming tree transducers
\cite{StreamingTreeTransd} or macro tree transducers
\cite{MacroTreeTransd}. The domains of transformations defined by
the latter are regular tree languages, which need not be the case in
our model due to the presence of variables. On the other hand our
model cannot recognize transformations which reverses a word (a tree
with unary alphabet and an end marker as a leaf), while macro tree
transducers and streaming tree transducers can. For exactly the same
reasons, our model is incomparable with \texorpdfstring{$k$}{k}-Pebble
Transducers \cite{MSV2000}.
Appendix~\ref{sec:kPebbleTransducerComparison} contains detailed
proofs of this incomparability.
%mention about attributed tree grammars

\paragraph*{Organization of the paper}
In Section~\ref{sec:illustratingExample}, we illustrate the correspondence
between the artefacts of our model and the parts of trees
and transformations that the model represents. We recall some
preliminaries about trees, contexts, alternating tree automata and
regular tree languages in Section~\ref{subsec:preliminaries} and formally define the
model in Section~\ref{subsec:model}. In
Section~\ref{sec:motiveEx}, we give some examples of possible
applications, which motivate our model as well as the type-checking problem that we
consider, which is formally defined in
Section~\ref{sec:problemsAndResults}. We give some intuition
underlying the decision procedure for type-checking problem in
Section~\ref{sec:proofOutline}, motivating the concept of relational
lifts that are formally defined in Section~\ref{sec:relationalLifts}.
The proof of decidability is put together in
Section~\ref{sec:proofDetails}. Some of the detailed proofs are moved
to the appendix due to space constraints.