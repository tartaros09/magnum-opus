\section{Introduction}\label{sec:introduction-trees}

Tree transformations in various forms of machines and logics have been studied for applications such as XML processing, programming languages, and HTML sanitization \cite{DVLM2015,Hosoya_2010,AK1998,MSV2000}. Classical formalisms for specifying tree transductions such as finite-state, top-down and bottom-up tree transducers, macro tree transducers, attribute grammars and MSO (Monadic Second-Order) definable graph transductions typically aim for robustness with respect to decidability of the equivalence problem and operations involving regular tree languages.

We introduce a model for tree transductions, targeting scenarios where the domain for which the transduction is defined is not necessarily regular, and undecidability of equivalence does not render the model useless. Expanding on the example from the abstract, consider expressions of the form $t \cdot e_1 + t \cdot e_2 + \cdots + t \cdot e_n$, where $n \in \N$ is any natural number. An equivalent expression is $t \cdot (e_1 + e_2 + \cdots + e_n)$. Transformations like this are routinely used in Horner's method, an efficient way to evaluate polynomials. We consider the corresponding expression trees and model this transformation by matching the source tree with a source pattern and the target tree with a target pattern. The patterns are themselves trees, which can have placeholder variables to represent subtrees like $t$ in the above example, which must repeat in multiple positions. The number $n$ can be arbitrary, so we need infinitely many pairs of patterns. For the example above, for each $n \in \N$ we need $(x \cdot e_1 + x \cdot e_2 + \cdots + x \cdot e_n\,, \quad x\cdot (e_1 + e_2 + \cdots + e_n)\,)$ as a  (source pattern, target pattern) pair, where $x$ is a place holder variable intended to match any expression $t$. We represent such infinite sets (of pairs of patterns) using (standard) tree transductions. We allow place holder variables in patterns to be substituted with any tree, as long as it satisfies a guard condition associated with the variable. The guard condition is given by a regular tree language called the guard language. It allows, for example, to restrict the expression $t$ above to be a valid expression. In some situations we may want to restrict it further, say to not contain any products inside. In this example, the set of source trees to which the transformation is applicable needs to have the same subtree $t$ repeat in multiple positions. Thus, the set of source trees on which transformations are defined need not be a regular tree language in general, which makes our model different from classical tree transductions. 

The backbone of our model is a finite representation of the infinite set of (source pattern, target pattern) pairs. Such a finite representation can be any formalism for tree transductions; in this paper we have chosen to use bimorphisms for technical convenience. Bimorphisms are given by a regular seed language $\seedLanguage$ and two morphisms $\sourceMap, \targetMap$. The transduction is defined as the relation $\{(\sourceMap(t), \targetMap(t)) \mid t \in \seedLanguage\}$. Over words, bimorphisms are equivalent to rational transductions \cite{Nivat68}. Over trees, bimorphisms capture subclasses of tree transducers (cf.~\cite[Section 6.5]{tata} and \cite{Engelfriet75}).

For example, consider the seed language   $a b 1(0+1)^\ast (\oplus b 1(0+1)^\ast)^\ast c$. This is a regular word language over the alphabet $\{a, b, c, \oplus, 0, 1\}$. We define the morphisms $\sourceMap, \targetMap$: $\{a, b, c, \oplus, 0, 1\} \to \{0,1, +, \cdot, x, (, ) \}^\ast$  as follows: $\sourceMap= \{a \mapsto \e, b \mapsto x \cdot {}, c \mapsto \e, \oplus \mapsto +, 0 \mapsto 0, 1 \mapsto 1\}$ and $\targetMap= \{a \mapsto x \cdot (, b \mapsto \e, c \mapsto ), \oplus \mapsto +, 0 \mapsto 0, 1 \mapsto 1\}$. Note that, this bimorphism generates pairs of the form $(x \cdot e_1 + x\cdot e_2 + \cdots + x\cdot e_n\,, \quad x\cdot (e_1 + e_2 + \cdots + e_n)\,)$ where $e_i$ is a nonzero binary number, from the seed word $a b e_1 \oplus b e_2 \oplus \dots \oplus b e_n c$. We may add a guard to $x$ saying that $x$ can take values only from $1(0+1)^\ast$, capturing completely the distributivity of multiplication over addition for binary numbers. Note that this only required bimorphisms over words and defines transduction over words. If instead we allow the guard language of $x$ to be any syntactically valid expression tree, this now defines transformations from trees to trees, though given by a bimorphism over words. In fact, if we wish $e_1, e_2 \dots e_n$ to be also expressions, we would require bimorphsim over trees. This case is detailed as an example in Section~\ref{???}.%\todo{please check!}

Notice that bimorphisms over words which does not produce placeholder variables anywhere already captures rational relations over words. Since equivalence-checking is undecidable for rational word relations \cite{FR1968, Griffiths1968}, it is undecidable for our model as well. However we show that the \tcp\ is decidable, for the transduction defined by bimorphisms over trees as well as producing variables in the output of both morphisms.  We first motivate the need for type-checking in the next paragraph, and give insights to our algorithm in the paragraphs following that.

Continuing with our example from above, we may want to check that applying the transformation does not increase the alternation between the operators $\cdot$ and $+$. This can be checked by verifying that if the transformation is applied to any tree from a language $L$ consisting of trees with alternation depth bounded by a constant $c$, the resulting tree is in $L$ as well. On the other hand, for reasons of numerical stability, we may be interested in ensuring that size of subtrees made up of only $+$ operator is bounded. It can be checked that this regular property is not preserved by the transformation. Instead of arithmetic expressions, if we consider boolean expressions made up of $\land$ and $\lor$ operators, we can reason about expressions being in normal forms like conjunctive normal form, disjunctive normal form etc. We consider the \tcp\ in general where the source trees have a property represented by a regular language $L_1$ and output trees are required to have a property represented by another (possibly different) regular language $L_2$.

The main idea of our decision procedure for the \tcp\ is the following observation: if the given instance of the \tcp\ is a negative instance, a counterexample is a single tree in the seed language $\seedLanguage$, satisfying multiple conditions under multiple transformations. On the source side, applying the morphism $\sourceMap$ to the seed tree and then applying a substitution for the placeholder variables should result in a tree in $L_1$. On the output side, applying the morphism $\targetMap$ to the same seed tree and then applying the same substitution for the placeholder variables should result in a tree in $L_2$. These conditions can be checked by an alternating tree automaton running on trees in the seed language, thus reducing the \tcp\ to emptiness-checking of alternating tree automata.

Along the way, we consider some related/simpler problems. The simple question of whether a given tree matches a given pattern is \npc, a result known already for words \cite{tata}. The special case of the \tcp\ where the transformation is given by a single pair of patterns is \exptc. This generalizes the work of pattern based string transformations \cite{AMP2022} to trees.

\paragraph*{Related work}
Pattern-based text transformations were considered for words in the paper \cite{AMP2022}, but these consisted only of one pair of patterns. We extend this in two ways --- by having  transformations of trees, and by having a formalism that consists of potentially infinitely many  pairs of patterns. 

There are many transducer models for trees. Our transformations subsume classical top-down and bottom-up tree transducers, even without any variables, thanks to the bimorphism feature. In fact it subsumes any relation on trees definable by bimorphisms \cite[Chapter 6]{tata}. However it is incomparable to streaming tree transducers \cite{StreamingTreeTransd} or macro tree transducers \cite{MacroTreeTransd}. The domains of transformations defined by the latter are regular tree languages, which need not be the case in our model due to the presence of variables. On the other hand our model cannot recognize transformations which reverses a word (a tree with unary alphabet and an end marker as a leaf), while macro tree transducers and streaming tree transducers can. For exactly the same reasons, our model is incomparable with \texorpdfstring{$k$}{k}-Pebble Transducers \cite{MSV2000}. Appendix~\ref{sec:comparisonWithKPebbleTransducers} contains detailed proofs of this incomparability.

\paragraph*{Organization of the paper}
In Section~\ref{sec:illustEx}, we illustrate the correspondence between the artefacts of our model and the parts of trees and transformations that the model represents. We recall some preliminaries about trees, contexts, alternating tree automata and regular tree languages in Section~\ref{subsec:preliminaries} and formally define the model in Section~\ref{subsec:model}. In Section~\ref{sec:motiveEx}, we give some examples of possible applications, which motivate our model as well as the \tcp\ that we consider, which is formally defined in Section~\ref{sec:typecheckingProblem}. We give some intuition underlying the decision procedure for \tcp\ in Section~\ref{sec:proofOutline}, motivating the concept of relational lifts that are formally defined in Section~\ref{sec:relationalLifts}. The proof of decidability is put together in Section~\ref{sec:proofDetails}. Some of the detailed proofs are moved to the appendix due to space constraints.