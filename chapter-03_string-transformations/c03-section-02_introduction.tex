%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%	Chapter 03, Section 02 - Introduction                                      %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{sec:c03-introduction}

We consider systems maintaining information in text format in scenarios where changes to the textual information should be tightly controlled. Often the textual information that is maintained conforms to some syntactic structure, such as that provided by context-free or regular languages. One of the desirable properties of such systems is that if the modification is applied to textual information that belongs to a specified language, the modified text should still belong to that language. In other words, the specified language should be invariant under the modifications allowed by the system. A typical example of such systems is maintaining configuration information in data centers, a task for which there are dedicated softwares such as  Apache ZooKeeper \cite{Zookeeper}. Resources such as GPUs can be allocated to processes running on the service and we would want to move GPUs from one process to another. Suppose we want to ensure that GPUs are not moved from high priority processes to low priority ones. Such tight control over the kind of modifications that are allowed is the main purpose of the formal model we introduce here. We study the complexity of checking whether a given regular language is invariant under the modifications allowed by a given system. Currently our model is for strings, for which the invariance-checking problem is already intractable.

One way to organise such information is to use models for business artifact systems \cite{AAAMR2016, HCDGDM2013, DHLV2018, DHPV2009, DLV2016}. These use databases to store information and have predefined actions that can modify this information. There are two issues with using database-driven systems as a model for maintaining configuration information. First, databases are an overkill for such applications. Even configuration management softwares are using more economical text files or simple data structures like trees for this purpose. Second, while these database-driven systems allow unbounded data domain, the domain is often uninterpreted and the only operation permitted on data is equality checking. Some works have considered numerical domains \cite{AAAM2019, DDV2012}, however string domains have not been considered yet. Hence, transformations on strings such as the ones implemented by Mealy machines would not be supported in database-driven system models. 
 
For modelling transformations on text files, another alternative one would think of are the traditional models of transducers. However, the main limitation of these is that they cannot restrict a transduction to be enabled at some non-regular set of strings. This is indeed needed for the configuration file example, as we may need to check that the text entered in two different fields are equal in order to enable a transformation. 
 
We propose a formal model that is inspired by the database-driven systems and has the power of simple transducers(Mealy machines) inside. Like the database-driven systems, our model has a set of actions, that transform a text to another one. In the database-driven systems, actions are guarded by queries with free variables, which also serve as handles in the database for manipulation. In our model, actions are guarded by templates, and for an action to be enabled at a text, the text should fit the template. A template is simply a pattern over variables. 

An action matches the input string to a source pattern over variables, storing parts of the input string in variables. Then it performs transductions on the strings stored in the variables, and outputs the (transduced) strings in a possibly different order, according to a target pattern over variables. 

We study the following problem: Given an action and a regular language, whether the regular language is invariant under the action. Invariance-check is a basic safety check. Regularity is powerful enough to express many sanity conditions and non-existence of some bugs.

We study the complexity of regular invariance-checking and show that it is \pspc. For a subclass of actions, where there are no variable repetitions in the source and target patterns and where the regular language is given by a deterministic finite-state automaton, we show it is \conpc. We further show that the problem is \woneh\ even with the length of the pattern as the parameter. Hence, the problem is unlikely to be fixed-parameter tractable with this parameter. 

\paragraph*{Comparison with Transducers: }Our model of actions is incomparable to classical models of transducers. For instance an action can match the entire input text to a single variable $x$ and after an identity transduction, it can rewrite it as $xx$. After performing this action once, the text files will be of the form $ww$, indicating that regularity is not preserved. In another example, the input can be scanned into a pattern of the form $xx$, thus enabling the action only at a non-regular  set of strings. 

Our model of actions is orthogonal to some of the expressive transducer models such as a streaming string transducers(SST) \cite{A2011}. Indeed, an SST can convert a text to a concatenation of projection to odd positions followed by projections to even positions. Our actions cannot do this. On the other hand we can enable actions at some non-regular inputs, which even a two-way SST cannot do. 
